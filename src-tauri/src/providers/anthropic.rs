use serde::{Deserialize, Serialize};

const ANTHROPIC_API_URL: &str = "https://api.anthropic.com/v1/messages";
const ANTHROPIC_VERSION: &str = "2023-06-01";

/// Anthropic API client
pub struct AnthropicClient {
    client: reqwest::Client,
    api_key: String,
}

/// Configuration for a chat request
pub struct ChatRequestConfig {
    pub model: String,
    pub messages: Vec<serde_json::Value>,
    pub system_prompt: Option<String>,
    pub max_tokens: u32,
    pub extended_thinking: Option<ThinkingConfig>,
    pub web_search_enabled: bool,
    pub code_execution_enabled: bool,
}

/// Configuration for extended thinking
pub struct ThinkingConfig {
    pub budget_tokens: u32,
}

/// Configuration for a discovery request
pub struct DiscoveryRequestConfig {
    pub model: String,
    pub system_prompt: String,
    pub conversation: String,
    pub extended_thinking_enabled: Option<bool>,
    pub thinking_budget: Option<u32>,
}

/// Parsed SSE events from Anthropic's streaming API
#[derive(Debug, Clone)]
pub enum AnthropicStreamEvent {
    ContentBlockStart {
        block_type: String,
        content_block: serde_json::Value,
    },
    ContentBlockDelta {
        text: Option<String>,
        thinking: Option<String>,
        citation: Option<Citation>, // citations_delta events
        input_json: Option<String>, // input_json_delta for tool use
    },
    ContentBlockStop,
    MessageStop,
    Done,
    Unknown,
}

/// Code execution tool use block (server_tool_use with bash/text_editor)
#[derive(Debug, Clone)]
pub struct CodeExecutionToolUse {
    pub id: String,
    pub name: String, // "bash_code_execution" or "text_editor_code_execution"
    pub input: CodeExecutionInput,
}

/// Input for code execution tools
#[derive(Debug, Clone)]
pub enum CodeExecutionInput {
    Bash { command: String },
    TextEditor { command: String, path: String, file_text: Option<String>, old_str: Option<String>, new_str: Option<String> },
}

/// Result from code execution
#[derive(Debug, Clone)]
pub struct CodeExecutionResult {
    pub tool_use_id: String,
    pub tool_name: String, // "bash_code_execution" or "text_editor_code_execution"
    pub stdout: Option<String>,
    pub stderr: Option<String>,
    pub return_code: Option<i32>,
    pub files: Vec<GeneratedFileInfo>,
    pub error: Option<String>,
}

/// File generated by code execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedFileInfo {
    pub file_id: String,
    pub filename: String,
    pub mime_type: Option<String>,
}

/// Citation from web search results (used for source list)
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Citation {
    pub url: String,
    pub title: String,
    pub cited_text: String,
}

/// Inline citation with character position for rendering in text
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct InlineCitation {
    pub url: String,
    pub title: String,
    pub cited_text: String,
    pub char_offset: usize, // Position in the response where citation marker should appear
}

impl AnthropicClient {
    pub fn new(api_key: String) -> Self {
        Self {
            client: reqwest::Client::new(),
            api_key,
        }
    }

    /// Build the request body for a chat message
    pub fn build_chat_request(&self, config: &ChatRequestConfig) -> serde_json::Value {
        let mut body = serde_json::json!({
            "model": config.model,
            "max_tokens": config.max_tokens,
            "stream": true,
            "messages": config.messages,
        });

        // Add extended thinking if enabled
        if let Some(thinking) = &config.extended_thinking {
            body["thinking"] = serde_json::json!({
                "type": "enabled",
                "budget_tokens": thinking.budget_tokens
            });
        }

        // Build tools array based on enabled features
        let mut tools: Vec<serde_json::Value> = Vec::new();

        if config.web_search_enabled {
            tools.push(serde_json::json!({
                "type": "web_search_20250305",
                "name": "web_search"
            }));
        }

        if config.code_execution_enabled {
            tools.push(serde_json::json!({
                "type": "code_execution_20250825",
                "name": "code_execution"
            }));
        }

        if !tools.is_empty() {
            body["tools"] = serde_json::json!(tools);
        }

        // Use prompt caching for the system prompt
        if let Some(system) = &config.system_prompt {
            body["system"] = serde_json::json!([
                {
                    "type": "text",
                    "text": system,
                    "cache_control": {"type": "ephemeral"}
                }
            ]);
        }

        body
    }

    /// Build the request body for a discovery request
    pub fn build_discovery_request(&self, config: &DiscoveryRequestConfig) -> serde_json::Value {
        let mut body = serde_json::json!({
            "model": config.model,
            "max_tokens": 4096,
            "stream": true,
            "system": [
                {
                    "type": "text",
                    "text": config.system_prompt,
                    "cache_control": {"type": "ephemeral"}
                }
            ],
            "tools": [{
                "type": "web_search_20250305",
                "name": "web_search"
            }],
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": config.conversation,
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                }
            ]
        });

        // Add extended thinking if enabled
        if config.extended_thinking_enabled.unwrap_or(false) {
            let budget = config.thinking_budget.unwrap_or(10000);
            body["thinking"] = serde_json::json!({
                "type": "enabled",
                "budget_tokens": budget
            });
            // Extended thinking requires higher max_tokens
            body["max_tokens"] = serde_json::json!(16000);
        }

        body
    }

    /// Send a streaming request and return the response
    pub async fn send_streaming_request(
        &self,
        body: &serde_json::Value,
    ) -> Result<reqwest::Response, String> {
        self.send_streaming_request_with_beta(body, None).await
    }

    /// Send a streaming request with optional beta header
    pub async fn send_streaming_request_with_beta(
        &self,
        body: &serde_json::Value,
        beta_header: Option<&str>,
    ) -> Result<reqwest::Response, String> {
        let mut request = self
            .client
            .post(ANTHROPIC_API_URL)
            .header("x-api-key", &self.api_key)
            .header("anthropic-version", ANTHROPIC_VERSION)
            .header("content-type", "application/json");

        // Add beta header if provided (e.g., for code execution)
        if let Some(beta) = beta_header {
            request = request.header("anthropic-beta", beta);
        }

        let response = request
            .json(body)
            .send()
            .await
            .map_err(|e| e.to_string())?;

        if !response.status().is_success() {
            let error_text = response.text().await.unwrap_or_default();
            return Err(format!("API error: {}", error_text));
        }

        Ok(response)
    }
}

/// Parse a single SSE data payload into an AnthropicStreamEvent
pub fn parse_sse_event(data: &str) -> AnthropicStreamEvent {
    if data == "[DONE]" {
        return AnthropicStreamEvent::Done;
    }

    let parsed: serde_json::Value = match serde_json::from_str(data) {
        Ok(v) => v,
        Err(_) => return AnthropicStreamEvent::Unknown,
    };

    let event_type = parsed["type"].as_str().unwrap_or("");

    match event_type {
        "content_block_start" => {
            let block_type = parsed["content_block"]["type"]
                .as_str()
                .unwrap_or("")
                .to_string();
            let content_block = parsed["content_block"].clone();
            AnthropicStreamEvent::ContentBlockStart {
                block_type,
                content_block,
            }
        }
        "content_block_delta" => {
            let delta_type = parsed["delta"]["type"].as_str().unwrap_or("");

            match delta_type {
                "citations_delta" => {
                    // Extract citation from citations_delta event
                    let citation_obj = &parsed["delta"]["citation"];
                    let citation = if let (Some(url), Some(title)) = (
                        citation_obj["url"].as_str(),
                        citation_obj["title"].as_str(),
                    ) {
                        Some(Citation {
                            url: url.to_string(),
                            title: title.to_string(),
                            cited_text: citation_obj["cited_text"]
                                .as_str()
                                .unwrap_or("")
                                .to_string(),
                        })
                    } else {
                        None
                    };
                    AnthropicStreamEvent::ContentBlockDelta {
                        text: None,
                        thinking: None,
                        citation,
                        input_json: None,
                    }
                }
                "input_json_delta" => {
                    // Tool use input JSON delta
                    let partial_json = parsed["delta"]["partial_json"].as_str().map(|s| s.to_string());
                    AnthropicStreamEvent::ContentBlockDelta {
                        text: None,
                        thinking: None,
                        citation: None,
                        input_json: partial_json,
                    }
                }
                _ => {
                    // text_delta or thinking_delta
                    let text = parsed["delta"]["text"].as_str().map(|s| s.to_string());
                    let thinking = parsed["delta"]["thinking"].as_str().map(|s| s.to_string());
                    AnthropicStreamEvent::ContentBlockDelta {
                        text,
                        thinking,
                        citation: None,
                        input_json: None,
                    }
                }
            }
        }
        "content_block_stop" => AnthropicStreamEvent::ContentBlockStop,
        "message_stop" => AnthropicStreamEvent::MessageStop,
        _ => AnthropicStreamEvent::Unknown,
    }
}

/// Check if a content block is a code execution tool use
pub fn is_code_execution_block(block_type: &str, content_block: &serde_json::Value) -> bool {
    if block_type != "server_tool_use" {
        return false;
    }
    let name = content_block["name"].as_str().unwrap_or("");
    name == "bash_code_execution" || name == "text_editor_code_execution"
}

/// Parse code execution tool use from content_block_start
pub fn parse_code_execution_tool_use(content_block: &serde_json::Value) -> Option<CodeExecutionToolUse> {
    let id = content_block["id"].as_str()?.to_string();
    let name = content_block["name"].as_str()?.to_string();
    let input_obj = &content_block["input"];

    let input = match name.as_str() {
        "bash_code_execution" => {
            let command = input_obj["command"].as_str().unwrap_or("").to_string();
            CodeExecutionInput::Bash { command }
        }
        "text_editor_code_execution" => {
            let command = input_obj["command"].as_str().unwrap_or("").to_string();
            let path = input_obj["path"].as_str().unwrap_or("").to_string();
            let file_text = input_obj["file_text"].as_str().map(|s| s.to_string());
            let old_str = input_obj["old_str"].as_str().map(|s| s.to_string());
            let new_str = input_obj["new_str"].as_str().map(|s| s.to_string());
            CodeExecutionInput::TextEditor { command, path, file_text, old_str, new_str }
        }
        _ => return None,
    };

    Some(CodeExecutionToolUse { id, name, input })
}

/// Check if a content block is a code execution result
pub fn is_code_execution_result(block_type: &str) -> bool {
    block_type == "bash_code_execution_tool_result" || block_type == "text_editor_code_execution_tool_result"
}

/// Parse code execution result from content_block_start
pub fn parse_code_execution_result(block_type: &str, content_block: &serde_json::Value) -> Option<CodeExecutionResult> {
    let tool_use_id = content_block["tool_use_id"].as_str()?.to_string();
    let content = &content_block["content"];

    let tool_name = if block_type == "bash_code_execution_tool_result" {
        "bash_code_execution".to_string()
    } else {
        "text_editor_code_execution".to_string()
    };

    // Parse stdout/stderr/return_code for bash execution
    let stdout = content["stdout"].as_str().map(|s| s.to_string());
    let stderr = content["stderr"].as_str().map(|s| s.to_string());
    let return_code = content["return_code"].as_i64().map(|n| n as i32);

    // Parse error if present
    let error = content["error"].as_str().map(|s| s.to_string());

    // Parse generated files from content.content array
    // The structure is: content_block.content.content[] where each item may have a file_id
    // Items with type "bash_code_execution_output" contain file_id for generated files
    let files = content["content"]
        .as_array()
        .map(|arr| {
            arr.iter()
                .filter_map(|item| {
                    // Output blocks have file_id for generated files
                    let file_id = item["file_id"].as_str()?.to_string();

                    // Get mime_type from the API response
                    let mime_type = item["mime_type"].as_str()
                        .or_else(|| item["media_type"].as_str())
                        .map(|s| s.to_string());

                    // Try to get filename from various possible fields
                    let mut filename = item["filename"]
                        .as_str()
                        .or_else(|| item["name"].as_str())
                        .map(|s| s.to_string());

                    // If no filename or no extension, construct from mime_type
                    if filename.is_none() || filename.as_ref().map(|f| !f.contains('.')).unwrap_or(false) {
                        let extension = mime_type.as_deref().and_then(|mt| {
                            match mt {
                                "text/csv" => Some("csv"),
                                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" => Some("xlsx"),
                                "application/vnd.ms-excel" => Some("xls"),
                                "application/pdf" => Some("pdf"),
                                "image/png" => Some("png"),
                                "image/jpeg" => Some("jpg"),
                                "application/json" => Some("json"),
                                "text/plain" => Some("txt"),
                                "text/html" => Some("html"),
                                "application/zip" => Some("zip"),
                                _ => mt.split('/').last()
                            }
                        });

                        let base_name = filename.unwrap_or_else(|| {
                            format!("file_{}", &file_id[..8.min(file_id.len())])
                        });

                        filename = Some(if let Some(ext) = extension {
                            if base_name.contains('.') {
                                base_name
                            } else {
                                format!("{}.{}", base_name, ext)
                            }
                        } else {
                            base_name
                        });
                    }

                    Some(GeneratedFileInfo {
                        file_id,
                        filename: filename.unwrap_or_else(|| "file".to_string()),
                        mime_type,
                    })
                })
                .collect()
        })
        .unwrap_or_default();

    Some(CodeExecutionResult {
        tool_use_id,
        tool_name,
        stdout,
        stderr,
        return_code,
        files,
        error,
    })
}

/// Add Anthropic-style cache_control to the last message in a conversation
pub fn add_cache_control_to_last_message(messages: &mut Vec<serde_json::Value>) {
    if let Some(last_msg) = messages.last_mut() {
        // Convert content to array format with cache_control if it's a string
        if let Some(content_str) = last_msg["content"].as_str() {
            last_msg["content"] = serde_json::json!([
                {
                    "type": "text",
                    "text": content_str,
                    "cache_control": {"type": "ephemeral"}
                }
            ]);
        } else if let Some(content_arr) = last_msg["content"].as_array() {
            // Content is already an array, add cache_control to the last block
            let mut new_content = content_arr.clone();
            if let Some(last_block) = new_content.last_mut() {
                last_block["cache_control"] = serde_json::json!({"type": "ephemeral"});
            }
            last_msg["content"] = serde_json::json!(new_content);
        }
    }
}

/// Calculate max_tokens based on extended thinking settings
/// Base output is 8192 tokens, plus thinking budget if extended thinking is enabled
pub fn calculate_max_tokens(extended_thinking_enabled: bool, thinking_budget: Option<u32>) -> u32 {
    if extended_thinking_enabled {
        8192 + thinking_budget.unwrap_or(10000)
    } else {
        8192
    }
}

/// File metadata from Anthropic Files API
#[derive(Debug, Serialize, Deserialize)]
pub struct FileMetadata {
    pub id: String,
    pub filename: String,
    pub mime_type: String,
    pub size_bytes: u64,
}

/// Fetch file metadata from Anthropic Files API to get mime_type
pub async fn fetch_file_metadata(api_key: &str, file_id: &str) -> Result<FileMetadata, String> {
    let client = reqwest::Client::new();
    let url = format!("https://api.anthropic.com/v1/files/{}", file_id);

    let response = client
        .get(&url)
        .header("x-api-key", api_key)
        .header("anthropic-version", ANTHROPIC_VERSION)
        .header("anthropic-beta", "files-api-2025-04-14")
        .send()
        .await
        .map_err(|e| format!("Failed to fetch file metadata: {}", e))?;

    if !response.status().is_success() {
        let error_text = response.text().await.unwrap_or_default();
        return Err(format!("File metadata API error: {}", error_text));
    }

    let metadata: FileMetadata = response
        .json()
        .await
        .map_err(|e| format!("Failed to parse file metadata: {}", e))?;

    Ok(metadata)
}
