use serde::{Deserialize, Serialize};

use crate::llm::tool_names;
use crate::mime_utils;

const ANTHROPIC_API_URL: &str = "https://api.anthropic.com/v1/messages";
const ANTHROPIC_VERSION: &str = "2023-06-01";

/// Anthropic API client
pub struct AnthropicClient {
    client: reqwest::Client,
    api_key: String,
}

/// Configuration for a chat request
pub struct ChatRequestConfig {
    pub model: String,
    pub messages: Vec<serde_json::Value>,
    pub system_prompt: Option<String>,
    pub max_tokens: u32,
    pub extended_thinking: Option<ThinkingConfig>,
    pub web_search_enabled: bool,
    pub code_execution_enabled: bool,
    pub container_id: Option<String>,
}

/// Configuration for extended thinking
/// Supports both Opus 4.5 (budget_tokens) and Opus 4.6 / Sonnet 4.6 (adaptive + effort)
pub struct ThinkingConfig {
    pub budget_tokens: Option<u32>,  // For Opus 4.5 (budget-based thinking)
    pub opus46_level: Option<String>,  // For Opus 4.6 / Sonnet 4.6: "off", "low", "medium", "high", "max", "adaptive"
}

/// Configuration for a discovery request
pub struct DiscoveryRequestConfig {
    pub model: String,
    pub system_prompt: String,
    pub conversation: String,
    pub extended_thinking_enabled: Option<bool>,
    pub thinking_budget: Option<u32>,
}

/// Parsed SSE events from Anthropic's streaming API
#[derive(Debug, Clone)]
pub enum AnthropicStreamEvent {
    MessageStart {
        container_id: Option<String>, // Container ID for code execution sandbox persistence
    },
    MessageDelta {
        container_id: Option<String>, // Container ID appears here in streaming responses
    },
    ContentBlockStart {
        block_type: String,
        content_block: serde_json::Value,
    },
    ContentBlockDelta {
        text: Option<String>,
        thinking: Option<String>,
        citation: Option<Citation>, // citations_delta events
        input_json: Option<String>, // input_json_delta for tool use
    },
    ContentBlockStop,
    MessageStop,
    Done,
    Unknown,
}

/// Result from code execution
#[derive(Debug, Clone)]
pub struct CodeExecutionResult {
    pub tool_name: String, // "bash_code_execution" or "text_editor_code_execution"
    pub stdout: Option<String>,
    pub stderr: Option<String>,
    pub return_code: Option<i32>,
    pub files: Vec<GeneratedFileInfo>,
    pub error: Option<String>,
}

/// File generated by code execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedFileInfo {
    pub file_id: String,
    pub filename: String,
    pub mime_type: Option<String>,
}

/// Citation from web search results (used for source list)
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Citation {
    pub url: String,
    pub title: String,
    pub cited_text: String,
}

/// Inline citation with character position for rendering in text
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct InlineCitation {
    pub url: String,
    pub title: String,
    pub cited_text: String,
    pub char_offset: usize, // Position in the response where citation marker should appear
}

impl AnthropicClient {
    pub fn new(api_key: String) -> Self {
        Self {
            client: reqwest::Client::new(),
            api_key,
        }
    }

    /// Build the request body for a chat message
    pub fn build_chat_request(&self, config: &ChatRequestConfig) -> serde_json::Value {
        let mut body = serde_json::json!({
            "model": config.model,
            "max_tokens": config.max_tokens,
            "stream": true,
            "messages": config.messages,
        });

        // Add container ID if provided (for code execution sandbox persistence)
        if let Some(container_id) = &config.container_id {
            body["container"] = serde_json::json!(container_id);
        }

        // Add extended thinking if enabled
        if let Some(thinking) = &config.extended_thinking {
            // Check if this uses adaptive thinking (Opus 4.6, Sonnet 4.6)
            if let Some(opus46_level) = &thinking.opus46_level {
                if opus46_level != "off" {
                    // Adaptive thinking (Opus 4.6 / Sonnet 4.6)
                    body["thinking"] = serde_json::json!({
                        "type": "adaptive"
                    });
                    // Add effort level unless "adaptive" (let Claude decide)
                    if opus46_level != "adaptive" {
                        body["output_config"] = serde_json::json!({
                            "effort": opus46_level
                        });
                    }
                }
            } else if let Some(budget_tokens) = thinking.budget_tokens {
                // Opus 4.5: Use budget-based thinking
                body["thinking"] = serde_json::json!({
                    "type": "enabled",
                    "budget_tokens": budget_tokens
                });
            }
        }

        // Build tools array based on enabled features
        let mut tools: Vec<serde_json::Value> = Vec::new();

        if config.web_search_enabled {
            tools.push(serde_json::json!({
                "type": "web_search_20250305",
                "name": "web_search"
            }));
        }

        if config.code_execution_enabled {
            tools.push(serde_json::json!({
                "type": "code_execution_20250825",
                "name": "code_execution"
            }));
        }

        if !tools.is_empty() {
            body["tools"] = serde_json::json!(tools);
        }

        // Use prompt caching for the system prompt
        if let Some(system) = &config.system_prompt {
            body["system"] = serde_json::json!([
                {
                    "type": "text",
                    "text": system,
                    "cache_control": {"type": "ephemeral"}
                }
            ]);
        }

        body
    }

    /// Build the request body for a discovery request
    pub fn build_discovery_request(&self, config: &DiscoveryRequestConfig) -> serde_json::Value {
        let mut body = serde_json::json!({
            "model": config.model,
            "max_tokens": 4096,
            "stream": true,
            "system": [
                {
                    "type": "text",
                    "text": config.system_prompt,
                    "cache_control": {"type": "ephemeral"}
                }
            ],
            "tools": [{
                "type": "web_search_20250305",
                "name": "web_search"
            }],
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": config.conversation,
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                }
            ]
        });

        // Add extended thinking if enabled
        if config.extended_thinking_enabled.unwrap_or(false) {
            // Check if this model uses adaptive thinking for discovery
            if config.model.starts_with("claude-opus-4-6") || config.model.starts_with("claude-sonnet-4-6") {
                // Adaptive thinking (Opus 4.6 / Sonnet 4.6): Use with low effort for discovery
                body["thinking"] = serde_json::json!({
                    "type": "adaptive"
                });
                body["output_config"] = serde_json::json!({
                    "effort": "low"
                });
                body["max_tokens"] = serde_json::json!(16000);
            } else {
                // Opus 4.5: Use budget-based thinking
                let budget = config.thinking_budget.unwrap_or(10000);
                body["thinking"] = serde_json::json!({
                    "type": "enabled",
                    "budget_tokens": budget
                });
                // Extended thinking requires higher max_tokens
                body["max_tokens"] = serde_json::json!(16000);
            }
        }

        body
    }

    /// Send a streaming request and return the response
    pub async fn send_streaming_request(
        &self,
        body: &serde_json::Value,
    ) -> Result<reqwest::Response, String> {
        self.send_streaming_request_with_beta(body, None).await
    }

    /// Send a streaming request with optional beta header
    pub async fn send_streaming_request_with_beta(
        &self,
        body: &serde_json::Value,
        beta_header: Option<&str>,
    ) -> Result<reqwest::Response, String> {
        let mut request = self
            .client
            .post(ANTHROPIC_API_URL)
            .header("x-api-key", &self.api_key)
            .header("anthropic-version", ANTHROPIC_VERSION)
            .header("content-type", "application/json");

        // Add beta header if provided (e.g., for code execution)
        if let Some(beta) = beta_header {
            request = request.header("anthropic-beta", beta);
        }

        let response = request
            .json(body)
            .send()
            .await
            .map_err(|e| e.to_string())?;

        if !response.status().is_success() {
            let error_text = response.text().await.unwrap_or_default();
            return Err(format!("API error: {}", error_text));
        }

        Ok(response)
    }
}

/// Parse a single SSE data payload into an AnthropicStreamEvent
pub fn parse_sse_event(data: &str) -> AnthropicStreamEvent {
    if data == "[DONE]" {
        return AnthropicStreamEvent::Done;
    }

    let parsed: serde_json::Value = match serde_json::from_str(data) {
        Ok(v) => v,
        Err(_) => return AnthropicStreamEvent::Unknown,
    };

    let event_type = parsed["type"].as_str().unwrap_or("");

    match event_type {
        "message_start" => {
            // Note: For streaming responses, container ID comes in message_delta, not message_start
            // We keep this here for potential future API changes or non-streaming compatibility
            let container_id = parsed["message"]["container"]["id"]
                .as_str()
                .map(|s| s.to_string());
            AnthropicStreamEvent::MessageStart { container_id }
        }
        "content_block_start" => {
            let block_type = parsed["content_block"]["type"]
                .as_str()
                .unwrap_or("")
                .to_string();
            let content_block = parsed["content_block"].clone();
            AnthropicStreamEvent::ContentBlockStart {
                block_type,
                content_block,
            }
        }
        "content_block_delta" => {
            let delta_type = parsed["delta"]["type"].as_str().unwrap_or("");

            match delta_type {
                "citations_delta" => {
                    // Extract citation from citations_delta event
                    let citation_obj = &parsed["delta"]["citation"];
                    let citation = if let (Some(url), Some(title)) = (
                        citation_obj["url"].as_str(),
                        citation_obj["title"].as_str(),
                    ) {
                        Some(Citation {
                            url: url.to_string(),
                            title: title.to_string(),
                            cited_text: citation_obj["cited_text"]
                                .as_str()
                                .unwrap_or("")
                                .to_string(),
                        })
                    } else {
                        None
                    };
                    AnthropicStreamEvent::ContentBlockDelta {
                        text: None,
                        thinking: None,
                        citation,
                        input_json: None,
                    }
                }
                "input_json_delta" => {
                    // Tool use input JSON delta
                    let partial_json = parsed["delta"]["partial_json"].as_str().map(|s| s.to_string());
                    AnthropicStreamEvent::ContentBlockDelta {
                        text: None,
                        thinking: None,
                        citation: None,
                        input_json: partial_json,
                    }
                }
                _ => {
                    // text_delta or thinking_delta
                    let text = parsed["delta"]["text"].as_str().map(|s| s.to_string());
                    let thinking = parsed["delta"]["thinking"].as_str().map(|s| s.to_string());
                    AnthropicStreamEvent::ContentBlockDelta {
                        text,
                        thinking,
                        citation: None,
                        input_json: None,
                    }
                }
            }
        }
        "content_block_stop" => AnthropicStreamEvent::ContentBlockStop,
        "message_delta" => {
            // Container ID appears in message_delta.delta.container.id for streaming responses
            let container_id = parsed["delta"]["container"]["id"]
                .as_str()
                .map(|s| s.to_string());
            AnthropicStreamEvent::MessageDelta { container_id }
        }
        "message_stop" => AnthropicStreamEvent::MessageStop,
        _ => AnthropicStreamEvent::Unknown,
    }
}

/// Check if a content block is a code execution tool use
pub fn is_code_execution_block(block_type: &str, content_block: &serde_json::Value) -> bool {
    if block_type != "server_tool_use" {
        return false;
    }
    let name = content_block["name"].as_str().unwrap_or("");
    name == tool_names::BASH_CODE_EXECUTION || name == tool_names::TEXT_EDITOR_CODE_EXECUTION
}

/// Check if a content block is a code execution result
pub fn is_code_execution_result(block_type: &str) -> bool {
    block_type == "bash_code_execution_tool_result" || block_type == "text_editor_code_execution_tool_result"
}

/// Parse code execution result from content_block_start
pub fn parse_code_execution_result(block_type: &str, content_block: &serde_json::Value) -> Option<CodeExecutionResult> {
    // Verify tool_use_id exists (required for valid result block)
    content_block["tool_use_id"].as_str()?;
    let content = &content_block["content"];

    let tool_name = if block_type == "bash_code_execution_tool_result" {
        tool_names::BASH_CODE_EXECUTION.to_string()
    } else {
        tool_names::TEXT_EDITOR_CODE_EXECUTION.to_string()
    };

    // Parse stdout/stderr/return_code for bash execution
    let stdout = content["stdout"].as_str().map(|s| s.to_string());
    let stderr = content["stderr"].as_str().map(|s| s.to_string());
    let return_code = content["return_code"].as_i64().map(|n| n as i32);

    // Parse error if present
    let error = content["error"].as_str().map(|s| s.to_string());

    // Parse generated files from content.content array
    // The structure is: content_block.content.content[] where each item may have a file_id
    // Items with type "bash_code_execution_output" contain file_id for generated files
    let files = content["content"]
        .as_array()
        .map(|arr| {
            arr.iter()
                .filter_map(|item| {
                    // Output blocks have file_id for generated files
                    let file_id = item["file_id"].as_str()?.to_string();

                    // Get mime_type from the API response
                    let mime_type = item["mime_type"].as_str()
                        .or_else(|| item["media_type"].as_str())
                        .map(|s| s.to_string());

                    // Try to get filename from various possible fields
                    let mut filename = item["filename"]
                        .as_str()
                        .or_else(|| item["name"].as_str())
                        .map(|s| s.to_string());

                    // If no filename or no extension, construct from mime_type
                    if filename.is_none() || filename.as_ref().map(|f| !f.contains('.')).unwrap_or(false) {
                        let extension = mime_type.as_deref().map(mime_utils::mime_to_extension_or_subtype);

                        let base_name = filename.unwrap_or_else(|| {
                            format!("file_{}", &file_id[..8.min(file_id.len())])
                        });

                        filename = Some(if let Some(ext) = extension {
                            if base_name.contains('.') {
                                base_name
                            } else {
                                format!("{}.{}", base_name, ext)
                            }
                        } else {
                            base_name
                        });
                    }

                    Some(GeneratedFileInfo {
                        file_id,
                        filename: filename.unwrap_or_else(|| "file".to_string()),
                        mime_type,
                    })
                })
                .collect()
        })
        .unwrap_or_default();

    Some(CodeExecutionResult {
        tool_name,
        stdout,
        stderr,
        return_code,
        files,
        error,
    })
}

/// Add Anthropic-style cache_control to the last message in a conversation
pub fn add_cache_control_to_last_message(messages: &mut Vec<serde_json::Value>) {
    if let Some(last_msg) = messages.last_mut() {
        // Convert content to array format with cache_control if it's a string
        if let Some(content_str) = last_msg["content"].as_str() {
            last_msg["content"] = serde_json::json!([
                {
                    "type": "text",
                    "text": content_str,
                    "cache_control": {"type": "ephemeral"}
                }
            ]);
        } else if let Some(content_arr) = last_msg["content"].as_array() {
            // Content is already an array, add cache_control to the last block
            let mut new_content = content_arr.clone();
            if let Some(last_block) = new_content.last_mut() {
                last_block["cache_control"] = serde_json::json!({"type": "ephemeral"});
            }
            last_msg["content"] = serde_json::json!(new_content);
        }
    }
}

/// Calculate max_tokens based on model and extended thinking settings
/// Opus 4.6 / Sonnet 4.6: Base 16384 tokens (can go up to 128K)
/// Opus 4.5: Base 8192 tokens, plus thinking budget if extended thinking is enabled
pub fn calculate_max_tokens(
    model: &str,
    extended_thinking_enabled: bool,
    thinking_budget: Option<u32>,
    opus46_level: Option<&str>,
) -> u32 {
    // Adaptive thinking models have higher base tokens and don't use budget
    if model.starts_with("claude-opus-4-6") || model.starts_with("claude-sonnet-4-6") {
        let level = opus46_level.unwrap_or("off");
        if level != "off" {
            // With thinking enabled, use higher max_tokens
            16384
        } else {
            8192
        }
    } else if extended_thinking_enabled {
        // Opus 4.5: base + budget
        8192 + thinking_budget.unwrap_or(10000)
    } else {
        8192
    }
}

/// File metadata from Anthropic Files API
#[derive(Debug, Serialize, Deserialize)]
pub struct FileMetadata {
    pub id: String,
    pub filename: String,
    pub mime_type: String,
    pub size_bytes: u64,
}

/// Fetch file metadata from Anthropic Files API to get mime_type
pub async fn fetch_file_metadata(api_key: &str, file_id: &str) -> Result<FileMetadata, String> {
    let client = reqwest::Client::new();
    let url = format!("https://api.anthropic.com/v1/files/{}", file_id);

    let response = client
        .get(&url)
        .header("x-api-key", api_key)
        .header("anthropic-version", ANTHROPIC_VERSION)
        .header("anthropic-beta", "files-api-2025-04-14")
        .send()
        .await
        .map_err(|e| format!("Failed to fetch file metadata: {}", e))?;

    if !response.status().is_success() {
        let error_text = response.text().await.unwrap_or_default();
        return Err(format!("File metadata API error: {}", error_text));
    }

    let metadata: FileMetadata = response
        .json()
        .await
        .map_err(|e| format!("Failed to parse file metadata: {}", e))?;

    Ok(metadata)
}

/// Fetch file content from Anthropic Files API and return as base64
pub async fn fetch_file_content_base64(api_key: &str, file_id: &str) -> Result<String, String> {
    let client = reqwest::Client::new();
    let url = format!("https://api.anthropic.com/v1/files/{}/content", file_id);

    let response = client
        .get(&url)
        .header("x-api-key", api_key)
        .header("anthropic-version", ANTHROPIC_VERSION)
        .header("anthropic-beta", "files-api-2025-04-14")
        .send()
        .await
        .map_err(|e| format!("Failed to fetch file content: {}", e))?;

    if !response.status().is_success() {
        let error_text = response.text().await.unwrap_or_default();
        return Err(format!("File content API error: {}", error_text));
    }

    let bytes = response
        .bytes()
        .await
        .map_err(|e| format!("Failed to read file content: {}", e))?;

    use base64::Engine;
    Ok(base64::engine::general_purpose::STANDARD.encode(&bytes))
}
