import { create } from 'zustand';
import type { Message, Attachment, Citation, InlineCitation, GeneratedFile } from '../lib/types';
import { deduplicateCitations } from '../lib/citationHelpers';
import { useSessionStore } from './sessionStore';

interface ChatState {
  messages: Message[];
  inputValue: string;
  attachments: Attachment[];
  isStreaming: boolean;
  streamingContent: string;
  streamingCitations: Citation[]; // Legacy - kept for backward compatibility
  streamingInlineCitations: InlineCitation[]; // New inline citations with positions
  streamingThinking: string; // Accumulated thinking/reasoning content
  thinkingStartTime: number | null; // When thinking started (for duration calculation)
  // Code execution state
  streamingExecutionCode: string; // The code being executed
  streamingExecutionOutput: string; // Accumulated stdout/stderr
  executionStartTime: number | null; // When execution started
  executionStatus: 'idle' | 'running' | 'completed' | 'failed'; // Current execution status
  executionError: string | null; // Error message if execution failed
  streamingGeneratedFiles: GeneratedFile[]; // Files generated by execution
  executionTextPosition: number | null; // Character position in streamingContent where execution started
  sessionLoadedAt: number | null; // Timestamp to trigger scroll to bottom on session load
  pendingTurnId: string | null; // Track the turnId for the current turn
  // Claude code execution container ID (persists sandbox state across requests)
  anthropicContainerId: string | null;

  // Focus management
  _focusChatInput: (() => void) | null;

  // Actions
  addMessage: (message: Omit<Message, 'id' | 'timestamp'>) => void;
  updateStreamingContent: (content: string) => void;
  addStreamingCitations: (citations: Citation[]) => void;
  addStreamingInlineCitations: (citations: InlineCitation[]) => void;
  appendStreamingThinking: (content: string) => void;
  // Execution actions
  setExecutionStarted: (code: string) => void;
  appendExecutionOutput: (output: string) => void;
  setExecutionCompleted: (files?: GeneratedFile[]) => void;
  setExecutionFailed: (error: string) => void;
  finalizeStreaming: () => void;
  setInput: (value: string) => void;
  appendToInput: (text: string) => void;
  clearInput: () => void;
  addAttachment: (attachment: Omit<Attachment, 'id'>) => void;
  removeAttachment: (id: string) => void;
  clearAttachments: () => void;
  setStreaming: (streaming: boolean) => void;
  clearChat: () => void;
  loadSession: (messages: Message[], anthropicContainerId?: string | null) => void;
  loadSessionWithStreaming: (
    messages: Message[],
    streamingContent: string,
    streamingCitations: Citation[],
    streamingInlineCitations: InlineCitation[],
    pendingTurnId: string,
    streamingThinking?: string
  ) => void;
  setPendingTurnId: (turnId: string | null) => void;
  setAnthropicContainerId: (containerId: string) => void;
  clearStreamingContent: () => void;
  registerChatInputFocus: (focusFn: () => void) => void;
  focusChatInput: () => void;
  updateGeneratedFilePreview: (messageId: string, fileId: string, imagePreview: string) => void;
}

export const useChatStore = create<ChatState>((set, get) => ({
  messages: [],
  inputValue: '',
  attachments: [],
  isStreaming: false,
  streamingContent: '',
  streamingCitations: [],
  streamingInlineCitations: [],
  streamingThinking: '',
  thinkingStartTime: null,
  // Code execution state
  streamingExecutionCode: '',
  streamingExecutionOutput: '',
  executionStartTime: null,
  executionStatus: 'idle',
  executionError: null,
  streamingGeneratedFiles: [],
  executionTextPosition: null,
  sessionLoadedAt: null,
  pendingTurnId: null,
  anthropicContainerId: null,
  _focusChatInput: null,

  addMessage: (message) => {
    set((state) => ({
      messages: [
        ...state.messages,
        {
          ...message,
          id: crypto.randomUUID(),
          timestamp: new Date(),
        },
      ],
    }));
    useSessionStore.getState().markDirty();
  },

  updateStreamingContent: (content) => set({ streamingContent: content }),

  addStreamingCitations: (citations) =>
    set((state) => ({
      streamingCitations: [...state.streamingCitations, ...citations],
    })),

  addStreamingInlineCitations: (citations) =>
    set((state) => ({
      streamingInlineCitations: [...state.streamingInlineCitations, ...citations],
    })),

  appendStreamingThinking: (content) =>
    set((state) => ({
      streamingThinking: state.streamingThinking + content,
      // Record start time on first thinking delta
      thinkingStartTime: state.thinkingStartTime ?? Date.now(),
    })),

  // Code execution actions
  setExecutionStarted: (code) =>
    set((state) => ({
      // Append new code to existing (multiple executions in one turn)
      streamingExecutionCode: state.streamingExecutionCode
        ? `${state.streamingExecutionCode}\n\n${code}`
        : code,
      // Don't reset output - accumulate across executions
      executionStartTime: state.executionStartTime ?? Date.now(),
      executionStatus: 'running',
      executionError: null,
      // Capture text position on first execution only
      executionTextPosition: state.executionTextPosition ?? state.streamingContent.length,
      // Don't reset generated files - accumulate across executions
    })),

  appendExecutionOutput: (output) =>
    set((state) => ({
      streamingExecutionOutput: state.streamingExecutionOutput + output,
    })),

  setExecutionCompleted: (files) =>
    set((state) => ({
      executionStatus: 'completed',
      // Accumulate files across multiple executions
      streamingGeneratedFiles: files
        ? [...state.streamingGeneratedFiles, ...files]
        : state.streamingGeneratedFiles,
    })),

  setExecutionFailed: (error) =>
    set({
      executionStatus: 'failed',
      executionError: error,
    }),

  finalizeStreaming: () => {
    const state = useChatStore.getState();
    if (!state.streamingContent) return;

    // Dedupe legacy citations by URL
    const uniqueCitations = deduplicateCitations(state.streamingCitations);

    // Inline citations are kept as-is (position matters, so no deduplication)
    const inlineCitations = state.streamingInlineCitations;

    // Calculate thinking duration if we had thinking content
    const thinkingDurationMs = state.streamingThinking && state.thinkingStartTime
      ? Date.now() - state.thinkingStartTime
      : undefined;

    // Calculate execution duration if we had execution
    const executionDurationMs = state.streamingExecutionCode && state.executionStartTime
      ? Date.now() - state.executionStartTime
      : undefined;

    set({
      messages: [
        ...state.messages,
        {
          id: crypto.randomUUID(),
          role: 'assistant',
          content: state.streamingContent,
          timestamp: new Date(),
          citations: uniqueCitations.length > 0 ? uniqueCitations : undefined,
          inlineCitations: inlineCitations.length > 0 ? inlineCitations : undefined,
          turnId: state.pendingTurnId ?? undefined,
          thinkingContent: state.streamingThinking || undefined,
          thinkingDurationMs,
          // Code execution fields
          executionCode: state.streamingExecutionCode || undefined,
          executionOutput: state.streamingExecutionOutput || undefined,
          executionDurationMs,
          executionStatus: state.executionStatus !== 'idle'
            ? (state.executionStatus === 'failed' ? 'error' : 'success')
            : undefined,
          executionError: state.executionError || undefined,
          executionTextPosition: state.executionTextPosition ?? undefined,
          generatedFiles: state.streamingGeneratedFiles.length > 0
            ? state.streamingGeneratedFiles
            : undefined,
        },
      ],
      streamingContent: '',
      streamingCitations: [],
      streamingInlineCitations: [],
      streamingThinking: '',
      thinkingStartTime: null,
      // Reset execution state
      streamingExecutionCode: '',
      streamingExecutionOutput: '',
      executionStartTime: null,
      executionStatus: 'idle',
      executionError: null,
      streamingGeneratedFiles: [],
      executionTextPosition: null,
      isStreaming: false,
    });
    useSessionStore.getState().markDirty();
  },

  setInput: (value) => set({ inputValue: value }),

  appendToInput: (text) =>
    set((state) => ({
      inputValue: state.inputValue ? `${state.inputValue}\n\n${text}` : text,
    })),

  clearInput: () => set({ inputValue: '' }),

  addAttachment: (attachment) =>
    set((state) => ({
      attachments: [
        ...state.attachments,
        {
          ...attachment,
          id: crypto.randomUUID(),
        },
      ],
    })),

  removeAttachment: (id) =>
    set((state) => ({
      attachments: state.attachments.filter((a) => a.id !== id),
    })),

  clearAttachments: () => set({ attachments: [] }),
  setStreaming: (streaming) => set({ isStreaming: streaming }),
  clearChat: () =>
    set({
      messages: [],
      inputValue: '',
      attachments: [],
      streamingContent: '',
      streamingCitations: [],
      streamingInlineCitations: [],
      streamingThinking: '',
      thinkingStartTime: null,
      streamingExecutionCode: '',
      streamingExecutionOutput: '',
      executionStartTime: null,
      executionStatus: 'idle',
      executionError: null,
      streamingGeneratedFiles: [],
      executionTextPosition: null,
      isStreaming: false,
      pendingTurnId: null,
      anthropicContainerId: null, // New session = new container
    }),

  loadSession: (messages, anthropicContainerId = null) =>
    set({
      messages,
      inputValue: '',
      attachments: [],
      streamingContent: '',
      streamingCitations: [],
      streamingInlineCitations: [],
      streamingThinking: '',
      thinkingStartTime: null,
      streamingExecutionCode: '',
      streamingExecutionOutput: '',
      executionStartTime: null,
      executionStatus: 'idle',
      executionError: null,
      streamingGeneratedFiles: [],
      executionTextPosition: null,
      isStreaming: false,
      sessionLoadedAt: Date.now(),
      pendingTurnId: null,
      anthropicContainerId: anthropicContainerId ?? null,
    }),

  loadSessionWithStreaming: (messages, streamingContent, streamingCitations, streamingInlineCitations, pendingTurnId, streamingThinking = '') =>
    set({
      messages,
      inputValue: '',
      attachments: [],
      streamingContent,
      streamingCitations,
      streamingInlineCitations,
      streamingThinking,
      thinkingStartTime: streamingThinking ? Date.now() : null,
      isStreaming: true,
      sessionLoadedAt: Date.now(),
      pendingTurnId,
    }),

  setPendingTurnId: (turnId) => set({ pendingTurnId: turnId }),

  setAnthropicContainerId: (containerId) => {
    set({ anthropicContainerId: containerId });
    // Mark session dirty so the container ID gets persisted
    useSessionStore.getState().markDirty();
  },

  clearStreamingContent: () => {
    const state = useChatStore.getState();
    // Find and remove the last user message, restore its content to input
    const lastUserMessageIndex = [...state.messages]
      .reverse()
      .findIndex((m) => m.role === 'user');

    if (lastUserMessageIndex !== -1) {
      const actualIndex = state.messages.length - 1 - lastUserMessageIndex;
      const lastUserMessage = state.messages[actualIndex];
      set({
        messages: state.messages.slice(0, actualIndex),
        inputValue: lastUserMessage.content,
        attachments: lastUserMessage.attachments ?? [],
        streamingContent: '',
        streamingCitations: [],
        streamingInlineCitations: [],
        streamingThinking: '',
        thinkingStartTime: null,
        streamingExecutionCode: '',
        streamingExecutionOutput: '',
        executionStartTime: null,
        executionStatus: 'idle',
        executionError: null,
        streamingGeneratedFiles: [],
        executionTextPosition: null,
        isStreaming: false,
        pendingTurnId: null,
      });
    } else {
      set({
        streamingContent: '',
        streamingCitations: [],
        streamingInlineCitations: [],
        streamingThinking: '',
        thinkingStartTime: null,
        streamingExecutionCode: '',
        streamingExecutionOutput: '',
        executionStartTime: null,
        executionStatus: 'idle',
        executionError: null,
        streamingGeneratedFiles: [],
        executionTextPosition: null,
        isStreaming: false,
        pendingTurnId: null,
      });
    }
  },

  registerChatInputFocus: (focusFn) => set({ _focusChatInput: focusFn }),

  focusChatInput: () => {
    const focusFn = get()._focusChatInput;
    if (focusFn) focusFn();
  },

  updateGeneratedFilePreview: (messageId, fileId, imagePreview) => {
    set((state) => ({
      messages: state.messages.map((msg) => {
        if (msg.id !== messageId || !msg.generatedFiles) return msg;
        return {
          ...msg,
          generatedFiles: msg.generatedFiles.map((file) =>
            file.file_id === fileId ? { ...file, image_preview: imagePreview } : file
          ),
        };
      }),
    }));
    useSessionStore.getState().markDirty();
  },
}));
